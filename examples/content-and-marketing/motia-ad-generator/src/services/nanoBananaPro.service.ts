// src/services/nanoBananaPro.service.ts

import { GoogleGenAI } from "@google/genai";
import { Logger } from "motia";
import mime from "mime";
import { writeFile } from "fs";
import * as fs from "fs";
import * as path from "path";

const GOOGLE_CLOUD_API_KEY = process.env.GOOGLE_CLOUD_API_KEY;

export interface GenerateAdImageConfig {
  prompt: string;
  productImages: string[];
  screenshot?: string;
  aspectRatio: "1:1" | "9:16";
}

export interface GeneratedAdResult {
  imagePath: string;
}

function saveBinaryFile(fileName: string, content: Buffer): Promise<void> {
  return new Promise((resolve, reject) => {
    writeFile(fileName, content, (err) => {
      if (err) {
        console.error(`Error writing file ${fileName}:`, err);
        reject(err);
      } else {
        console.log(`File ${fileName} saved to file system.`);
        resolve();
      }
    });
  });
}

export async function generateAdImage(
  config: GenerateAdImageConfig,
  logger?: Logger
): Promise<GeneratedAdResult> {
  if (!GOOGLE_CLOUD_API_KEY) {
    throw new Error("GOOGLE_CLOUD_API_KEY not set in environment variables");
  }

  const ai = new GoogleGenAI({
    apiKey: GOOGLE_CLOUD_API_KEY,
  });

  logger?.info("Starting ad image generation", {
    productImageCount: config.productImages.length,
    aspectRatio: config.aspectRatio,
    promptLength: config.prompt.length,
  });

  const model = "gemini-3-pro-image-preview";

  // Build parts array: text first, then images
  const parts: any[] = [];

  // 1. Add text prompt
  parts.push({
    text: config.prompt,
  });

  // 2. Add product images (up to 10)
  for (const imgUrl of config.productImages.slice(0, 10)) {
    const mimeType = imgUrl.toLowerCase().match(/\.(jpe?g)$/i)
      ? "image/jpeg"
      : "image/png";

    parts.push({
      fileData: {
        mimeType,
        fileUri: imgUrl,
      },
    });
  }

  // 3. Add screenshot (optional)
  if (config.screenshot) {
    parts.push({
      fileData: {
        mimeType: "image/png",
        fileUri: config.screenshot,
      },
    });
  }

  logger?.info("Prepared request parts", {
    totalParts: parts.length,
  });

  // Config (following working sample)
  const generationConfig = {
    responseModalities: ["IMAGE", "TEXT"],
    imageConfig: {
      imageSize: "2K",
      aspectRatio: config.aspectRatio,
    },
  };

  // Contents
  const contents = [
    {
      role: "user",
      parts,
    },
  ];

  logger?.info("Calling Nano Banana Pro API via generateContentStream");

  // Call API with streaming (following working sample)
  const response = await ai.models.generateContentStream({
    model,
    config: generationConfig,
    contents,
  });

  // Prepare output directory
  const outputDir = path.join(process.cwd(), "outputs");
  fs.mkdirSync(outputDir, { recursive: true });

  const timestamp = Date.now();
  const aspectRatioLabel = config.aspectRatio.replace(":", "x");
  let savedFilePath: string | null = null;

  logger?.info("Processing stream response");

  // Process stream (following working sample)
  let fileIndex = 0;
  for await (const chunk of response) {
    if (
      !chunk.candidates ||
      !chunk.candidates[0]?.content ||
      !chunk.candidates[0]?.content?.parts
    ) {
      continue;
    }

    // Check for image data (following working sample)
    if (chunk.candidates?.[0]?.content?.parts?.[0]?.inlineData) {
      const fileName = `ad_${aspectRatioLabel}_${timestamp}_${fileIndex++}`;
      const inlineData = chunk.candidates[0].content.parts[0].inlineData;
      const fileExtension = mime.getExtension(inlineData.mimeType || "");
      const buffer = Buffer.from(inlineData.data || "", "base64");

      const filepath = path.join(outputDir, `${fileName}.${fileExtension}`);
      await saveBinaryFile(filepath, buffer);

      savedFilePath = filepath;

      logger?.info("Image saved", {
        filepath,
        fileSize: buffer.length,
      });
    } else {
      // Log text response
      if (chunk.text) {
        logger?.info("Received text chunk", { text: chunk.text });
      }
    }
  }

  if (!savedFilePath) {
    throw new Error(
      "No image generated by Nano Banana Pro. Check API response."
    );
  }

  logger?.info("Ad generation completed successfully", {
    imagePath: savedFilePath,
  });

  return {
    imagePath: savedFilePath,
  };
}

export const NanoBananaProService = {
  generateAdImage,
};

export default NanoBananaProService;
