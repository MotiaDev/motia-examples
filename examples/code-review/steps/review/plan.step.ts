import { EventConfig, StepHandler } from 'motia';
import { z } from 'zod';
import * as fs from 'fs';
import * as path from 'path';

// Define input schema for composed plan
const sectionSchema = z.object({
  heading: z.string(),
  content: z.string()
});

const inputSchema = z.object({
  title: z.string(),
  sections: z.array(sectionSchema),
  timestamp: z.string()
});

export const config: EventConfig = {
  type: 'event',
  name: 'Plan',
  description: 'Finalizes and outputs the code review plan',
  subscribes: ['review.planComposed'],
  emits: ['review.done'],
  flows: ['code-review-flow'],
  input: inputSchema
};

export const handler: StepHandler<typeof config> = async (input, { emit, logger, state, traceId }) => {
  logger.info('Finalizing code review plan');

  try {
    // Generate plan content in Markdown format
    const planContent = generateMarkdownPlan(input);
    
    // In a production environment, you might:
    // 1. Write to a file
    // 2. Save to a database
    // 3. Send to an external service
    
    // For demonstration, we'll log the content
    logger.info('Plan content generated', { 
      length: planContent.length,
      previewLines: planContent.split('\n').slice(0, 3)
    });
    
    // For demonstration purposes, we'll try to write to a file
    // In a real implementation, this would use a more robust approach
    try {
      const outputDir = path.resolve(process.cwd(), 'output');
      
      // Create output directory if it doesn't exist
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }
      
      const filename = `CodeReviewPlan_${new Date().toISOString().replace(/[:.]/g, '-')}.md`;
      const filePath = path.join(outputDir, filename);
      
      fs.writeFileSync(filePath, planContent);
      logger.info('Plan written to file', { filePath });
    } catch (fileError) {
      logger.warn('Could not write plan to file', { 
        error: fileError instanceof Error ? fileError.message : String(fileError) 
      });
    }
    
    // Emit completion event
    await emit({
      topic: 'review.done',
      data: {
        planTitle: input.title,
        sectionCount: input.sections.length,
        timestamp: new Date().toISOString()
      }
    });
    
    logger.info('Code review plan finalized');
  } catch (error) {
    logger.error('Error finalizing plan', { error: error instanceof Error ? error.message : String(error) });
  }
};

// Helper function to generate Markdown plan
function generateMarkdownPlan(plan: any): string {
  const lines: string[] = [];
  
  // Add title
  lines.push(`# ${plan.title}`);
  lines.push('');
  
  // Add timestamp
  lines.push(`*Generated on: ${new Date(plan.timestamp).toLocaleString()}*`);
  lines.push('');
  
  // Add each section
  plan.sections.forEach((section: any) => {
    lines.push(`## ${section.heading}`);
    lines.push('');
    lines.push(section.content);
    lines.push('');
  });
  
  // Add footer
  lines.push('---');
  lines.push('*This plan was automatically generated by the Code Review Agent.*');
  
  return lines.join('\n');
} 